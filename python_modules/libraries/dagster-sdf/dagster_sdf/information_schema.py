from pathlib import Path
from typing import Dict, Literal, Mapping, Optional, Set, Tuple, Union

import dagster._check as check
import polars as pl
from dagster import AssetKey, AssetOut, Nothing
from dagster._record import IHaveNew, record_custom

from .asset_utils import dagster_name_fn, default_asset_key_fn
from .constants import (
    DEFAULT_SDF_WORKSPACE_ENVIRONMENT,
    SDF_INFORMATION_SCHEMA_TABLES,
    SDF_TARGET_DIR,
)


@record_custom(checked=False)
class SdfInformationSchema(IHaveNew):
    """A class to represent the SDF information schema.

    The information schema is a set of tables that are generated by the sdf cli on compilation.
    It can be queried directly via the sdf cli, or by reading the parquet files that live in the
    `sdftarget` directory.

    This class specifically interfaces with the tables and columns tables, which contain metadata
    on their upstream and downstream dependencies, as well as their schemas, descriptions, classifiers,
    and other metadata.

    Read more about the information schema here: https://docs.sdf.com/reference/sdf-information-schema#sdf-information-schema

    Args:
        target_dir (Union[Path, str]): The path to the target directory.
        environment (str, optional): The environment to use. Defaults to "dbg".
    """

    information_schema_dir: Path
    information_schema: Dict[str, pl.DataFrame]

    def __new__(
        cls,
        target_dir: Union[Path, str],
        environment: str = DEFAULT_SDF_WORKSPACE_ENVIRONMENT,
    ):
        check.inst_param(target_dir, "target_dir", (str, Path))
        check.str_param(environment, "environment")

        information_schema_dir = Path(
            target_dir, SDF_TARGET_DIR, environment, "data", "system", "information_schema::sdf"
        )
        check.invariant(
            information_schema_dir.exists(),
            f"Information schema directory {information_schema_dir} does not exist.",
        )

        return super().__new__(
            cls,
            information_schema_dir=information_schema_dir,
            information_schema={},
        )

    def read_table(
        self, table_name: Literal["tables", "columns", "table_lineage", "column_lineage"]
    ) -> pl.DataFrame:
        check.invariant(
            table_name in SDF_INFORMATION_SCHEMA_TABLES,
            f"Table `{table_name}` is not valid information schema table."
            f" Select from one of {SDF_INFORMATION_SCHEMA_TABLES}.",
        )

        return self.information_schema.setdefault(
            table_name, pl.read_parquet(self.information_schema_dir.joinpath(table_name))
        )

    def build_sdf_multi_asset_args(
        self, io_manager_key: Optional[str]
    ) -> Tuple[Mapping[str, AssetOut], Dict[str, Set[AssetKey]]]:
        outs: Dict[str, AssetOut] = {}
        internal_asset_deps: Dict[str, Set[AssetKey]] = {}

        for table_row in self.read_table("tables").rows(named=True):
            if table_row["purpose"] in ["system", "external-system"]:
                continue
            if table_row["origin"] == "remote":
                continue

            asset_key = default_asset_key_fn(table_row["table_id"])
            output_name = dagster_name_fn(table_row["table_id"])

            outs[output_name] = AssetOut(
                key=asset_key,
                dagster_type=Nothing,
                io_manager_key=io_manager_key,
                description=table_row["description"],
                is_required=False,
            )
            internal_asset_deps[output_name] = {
                default_asset_key_fn(dep) for dep in table_row["depends_on"]
            }

        return outs, internal_asset_deps
